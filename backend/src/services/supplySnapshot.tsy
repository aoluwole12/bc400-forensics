# (paste, then Ctrl+O, Enter, Ctrl+X)

# rebuild + rerun snapshot
npm run build
npm run snapshot:supplyimport type { Pool } from "pg";
import { ethers } from "ethers";

const ERC20_ABI = [
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  "function decimals() view returns (uint8)",
  "function totalSupply() view returns (uint256)",
  "function balanceOf(address) view returns (uint256)",
];

const PAIR_ABI = [
  "function token0() view returns (address)",
  "function token1() view returns (address)",
  "function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)",
];

const CHAINLINK_AGG_ABI = [
  "function latestRoundData() view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)",
  "function decimals() view returns (uint8)",
];

function mustAddr(label: string, v?: string) {
  const val = (v ?? "").trim();
  if (!/^0x[a-fA-F0-9]{40}$/.test(val)) throw new Error(`Missing/invalid ${label}: "${val}"`);
  return val;
}

function addrOrEmpty(v?: string) {
  const val = (v ?? "").trim();
  return /^0x[a-fA-F0-9]{40}$/.test(val) ? val : "";
}

export type SupplySnapshotInsert = {
  token_address: string; // REQUIRED by DB schema
  ts: Date;
  total_supply_raw: string;
  burned_raw: string;
  lp_raw: string;
  locked_raw: string;
  circulating_raw: string;
  price_usd: string | null;
  marketcap_usd: string | null;
  metadata: any;
};

export async function buildSupplySnapshot(): Promise<{ snapshot: SupplySnapshotInsert }> {
  const rpcUrl = (process.env.BSC_RPC_URL || "").trim();
  if (!rpcUrl) throw new Error("Missing BSC_RPC_URL");

  const tokenAddress = mustAddr("BC400_TOKEN_ADDRESS", process.env.BC400_TOKEN_ADDRESS);
  const pairAddress = mustAddr("BC400_PAIR_ADDRESS", process.env.BC400_PAIR_ADDRESS);

  // optional known wallets
  const treasury = addrOrEmpty(process.env.BC400_TREASURY_WALLET);
  const devburn = addrOrEmpty(process.env.BC400_DEV_BURN_WALLET);
  const lockedAddr = addrOrEmpty(process.env.BC400_LOCKED_ADDRESS);

  // Common burn/zero addresses
  const burnDead = "0x000000000000000000000000000000000000dEaD";
  const zeroAddr = "0x0000000000000000000000000000000000000000";

  const provider = new ethers.JsonRpcProvider(rpcUrl);

  const token = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
  const pair = new ethers.Contract(pairAddress, PAIR_ABI, provider);

  const [name, symbol, decimals, totalSupply] = await Promise.all([
    token.name().catch(() => "Unknown"),
    token.symbol().catch(() => "UNKNOWN"),
    token.decimals().catch(() => 18),
    token.totalSupply(),
  ]);

  const burnDeadLower = burnDead.toLowerCase();
  const devburnLower = devburn ? devburn.toLowerCase() : "";

  const [burnDeadBal, zeroBal, lpBal, devburnBal, lockedRaw] = await Promise.all([
    token.balanceOf(burnDead),
    token.balanceOf(zeroAddr),
    token.balanceOf(pairAddress),

    // ✅ don't double-count devburn if it equals dead wallet
    devburnLower && devburnLower !== burnDeadLower ? token.balanceOf(devburn) : Promise.resolve(0n),

    // ✅ lockedRaw is now always defined
    lockedAddr ? token.balanceOf(lockedAddr) : Promise.resolve(0n),
  ]);

  const burnedRaw = burnDeadBal + zeroBal + devburnBal;

  // ✅ circulatingRaw calculation uses lockedRaw (now defined)
  let circulatingRaw = totalSupply - burnedRaw - lpBal - lockedRaw;

  // safety: never negative
  if (circulatingRaw < 0n) circulatingRaw = 0n;

  // -------- Price (USD) --------
  const wbnb = (process.env.WBNB_ADDRESS ||
    "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c").toLowerCase();

  const [token0, token1, reserves] = await Promise.all([
    pair.token0(),
    pair.token1(),
    pair.getReserves(),
  ]);

  const t0 = String(token0).toLowerCase();
  const t1 = String(token1).toLowerCase();

  const reserve0 = BigInt(reserves[0].toString());
  const reserve1 = BigInt(reserves[1].toString());

  const tokenAddrLower = tokenAddress.toLowerCase();
  const tokenDecimals = Number(decimals);
  const wbnbDecimals = 18;

  let priceInWbnb: number | null = null;

  if (reserve0 > 0n && reserve1 > 0n) {
    if (t0 === tokenAddrLower && t1 === wbnb) {
      const rWbnb = parseFloat(ethers.formatUnits(reserve1, wbnbDecimals));
      const rToken = parseFloat(ethers.formatUnits(reserve0, tokenDecimals));
      if (rToken > 0) priceInWbnb = rWbnb / rToken;
    } else if (t1 === tokenAddrLower && t0 === wbnb) {
      const rWbnb = parseFloat(ethers.formatUnits(reserve0, wbnbDecimals));
      const rToken = parseFloat(ethers.formatUnits(reserve1, tokenDecimals));
      if (rToken > 0) priceInWbnb = rWbnb / rToken;
    }
  }

  // BNB/USD from Chainlink
  const bnbUsdFeed = (process.env.BNB_USD_FEED || "").trim();
  let bnbUsd: number | null = null;

  if (bnbUsdFeed) {
    const feed = new ethers.Contract(bnbUsdFeed, CHAINLINK_AGG_ABI, provider);
    const [round, feedDecimals] = await Promise.all([feed.latestRoundData(), feed.decimals()]);
    const ans = BigInt(round[1].toString());
    if (ans > 0n) {
      bnbUsd = Number(ans) / Math.pow(10, Number(feedDecimals));
    }
  }

  const priceUsd = priceInWbnb != null && bnbUsd != null ? priceInWbnb * bnbUsd : null;

  const circulatingHuman = parseFloat(ethers.formatUnits(circulatingRaw, tokenDecimals));
  const marketcapUsd =
    priceUsd != null && Number.isFinite(circulatingHuman) ? priceUsd * circulatingHuman : null;

  const metadata = {
    name,
    symbol,
    decimals: tokenDecimals,
    tokenAddress,
    pairAddress,
    token0: t0,
    token1: t1,
    reserve0: reserve0.toString(),
    reserve1: reserve1.toString(),
    wbnbAddress: wbnb,
    bnbUsdFeed: bnbUsdFeed || null,
    treasury: treasury || null,
    devburn: devburn || null,
    lockedAddress: lockedAddr || null,
    computed: { priceInWbnb, bnbUsd },
  };

  const snapshot: SupplySnapshotInsert = {
    token_address: tokenAddress,
    ts: new Date(),
    total_supply_raw: totalSupply.toString(),
    burned_raw: burnedRaw.toString(),
    lp_raw: lpBal.toString(),
    locked_raw: lockedRaw.toString(), // ✅ now valid
    circulating_raw: circulatingRaw.toString(),
    price_usd: priceUsd != null ? String(priceUsd) : null,
    marketcap_usd: marketcapUsd != null ? String(marketcapUsd) : null,
    metadata,
  };

  return { snapshot };
}

export async function insertSupplySnapshot(pool: Pool) {
  const { snapshot } = await buildSupplySnapshot();

  await pool.query(
    `
    INSERT INTO public.supply_snapshots (
      token_address,
      ts,
      total_supply_raw,
      burned_raw,
      lp_raw,
      locked_raw,
      circulating_raw,
      price_usd,
      marketcap_usd,
      metadata
    ) VALUES (
      $1,$2,$3,$4,$5,$6,$7,$8,$9,$10
    )
    `,
    [
      snapshot.token_address,
      snapshot.ts,
      snapshot.total_supply_raw,
      snapshot.burned_raw,
      snapshot.lp_raw,
      snapshot.locked_raw,
      snapshot.circulating_raw,
      snapshot.price_usd,
      snapshot.marketcap_usd,
      snapshot.metadata,
    ]
  );

  return snapshot;
}
