import "dotenv/config";
import express from "express";
import cors from "cors";
import { pool } from "./db";
import { JsonRpcProvider, Contract } from "ethers";

// ✅ NEW: route registrars (files must exist in src/routes/)
import { registerDexPriceRoute } from "./routes/dexPrice";
import { registerSecurityRulesRoute } from "./routes/securityRules";

const PORT = Number(process.env.PORT || 4000);

const app = express();
app.use(cors());
app.use(express.json());

// ----------------------
// Small helper for logging + consistent error JSON
// ----------------------
function handleError(res: express.Response, where: string, err: unknown) {
  console.error(`Error in ${where}:`, err);
  res.status(500).json({
    error: `Failed to load ${where}`,
    details: err instanceof Error ? err.message : String(err),
  });
}

// ----------------------
// Chain constants (no env required)
// ----------------------
// Your BC400 token CA (fallback if env not present)
const BC400_TOKEN =
  (process.env.BC400_TOKEN_ADDRESS || "0x61Fc93c7C070B32B1b1479B86056d8Ec1D7125BD").toLowerCase();

// WBNB (canonical)
const WBNB_TOKEN = "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c".toLowerCase();

// PancakeSwap v2 Factory (BSC)
const PANCAKE_V2_FACTORY = "0xCA143Ce32Fe78f1f7019d7d551a6402fC5350c73";

// Dead + zero burn addresses
const DEAD = "0x000000000000000000000000000000000000dEaD";
const ZERO = "0x0000000000000000000000000000000000000000";

// Provider (no env required)
function getProvider() {
  const rpc =
    process.env.RPC_URL ||
    process.env.BSC_RPC_URL ||
    process.env.NODEREAL_HTTP ||
    "https://bsc-dataseed.binance.org/";
  return new JsonRpcProvider(rpc);
}

const ERC20_ABI = [
  "function symbol() view returns (string)",
  "function decimals() view returns (uint8)",
  "function totalSupply() view returns (uint256)",
  "function balanceOf(address) view returns (uint256)",
];

const FACTORY_ABI = [
  "function getPair(address tokenA, address tokenB) external view returns (address pair)",
];

// ----------------------
// Root homepage (fixes "Cannot GET /")
// ----------------------
app.get("/", (_req, res) => {
  res.status(200).type("html").send(`
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BC400 Forensics API</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 32px; line-height: 1.5; }
    code { background: #f3f3f3; padding: 2px 6px; border-radius: 6px; }
    .card { max-width: 820px; border: 1px solid #e6e6e6; border-radius: 12px; padding: 18px; }
    ul { margin: 10px 0 0 18px; }
    a { text-decoration: none; }
    a:hover { text-decoration: underline; }
    .muted { color: #666; }
  </style>
</head>
<body>
  <div class="card">
    <h1>BC400 Forensics API</h1>
    <p class="muted">You reached the API service. Try these endpoints:</p>
    <ul>
      <li><a href="/health"><code>/health</code></a> (and <a href="/api/health"><code>/api/health</code></a>)</li>
      <li><a href="/summary"><code>/summary</code></a> (and <a href="/api/summary"><code>/api/summary</code></a>)</li>
      <li><a href="/top-holders"><code>/top-holders</code></a> (and <a href="/api/top-holders"><code>/api/top-holders</code></a>)</li>
      <li><a href="/transfers"><code>/transfers</code></a> (and <a href="/api/transfers"><code>/api/transfers</code></a>)</li>
      <li><a href="/dex/price"><code>/dex/price</code></a></li>
      <li><a href="/lp/lock"><code>/lp/lock</code></a> (and <a href="/api/lp/lock"><code>/api/lp/lock</code></a>)</li>
      <li><a href="/security/rules"><code>/security/rules</code></a></li>
    </ul>
    <p class="muted" style="margin-top: 14px;">
      Note: <code>/sql</code> is POST-only (SELECT-only).
    </p>
  </div>
</body>
</html>
  `);
});

// ----------------------
// Health check (support both /health and /api/health)
// ----------------------
async function healthHandler(_req: express.Request, res: express.Response) {
  try {
    const client = await pool.connect();
    client.release();
    res.json({ ok: true });
  } catch (err) {
    handleError(res, "health", err);
  }
}
app.get("/health", healthHandler);
app.get("/api/health", healthHandler);

// ----------------------
// /summary – chain snapshot (support /api/summary too)
// ----------------------
async function summaryHandler(_req: express.Request, res: express.Response) {
  const client = await pool.connect();
  try {
    const stats = await client.query<{
      first_block: string | null;
      last_block: string | null;
      total_transfers: string;
    }>(
      `
      SELECT
        MIN(block_number)::bigint AS first_block,
        MAX(block_number)::bigint AS last_block,
        COUNT(*)::bigint          AS total_transfers
      FROM transfers;
      `
    );

    const row = stats.rows[0];

    const wallets = await client.query<{ total_wallets: string }>(
      `SELECT COUNT(*)::bigint AS total_wallets FROM addresses;`
    );

    res.json({
      firstBlock: row?.first_block ? Number(row.first_block) : null,
      lastIndexedBlock: row?.last_block ? Number(row.last_block) : null,
      totalTransfers: row ? Number(row.total_transfers) : 0,
      totalWallets: wallets.rows[0] ? Number(wallets.rows[0].total_wallets) : 0,
    });
  } catch (err) {
    handleError(res, "summary", err);
  } finally {
    client.release();
  }
}
app.get("/summary", summaryHandler);
app.get("/api/summary", summaryHandler);

// ----------------------
// /top-holders – from holder_balances snapshot (support /api/top-holders too)
// ----------------------
async function topHoldersHandler(req: express.Request, res: express.Response) {
  const client = await pool.connect();
  try {
    const limit = Math.min(Mathmax(Number(req.query.limit) || 25, 1), 200);

    const result = await client.query<{
      address_id: number;
      address: string;
      balance_bc400: string;
      balance_raw: string;
      tx_count: number;
      tags: string | null;
      first_seen: string;
      last_seen: string;
      last_block_number: string | null;
      last_block_time: string | null;
      last_tx_hash: string | null;
    }>(
      `
      SELECT
        hb.address_id,
        a.address,
        hb.balance_bc400,
        hb.balance_raw,
        hb.tx_count,
        hb.tags,
        hb.first_seen,
        hb.last_seen,
        hb.last_block_number,
        hb.last_block_time,
        hb.last_tx_hash
      FROM holder_balances hb
      JOIN addresses a
        ON a.id = hb.address_id
      WHERE hb.balance_bc400 > 0
      ORDER BY hb.balance_bc400 DESC
      LIMIT $1;
      `,
      [limit]
    );

    res.json({
      holders: result.rows.map((r, idx) => ({
        rank: idx + 1,
        addressId: r.address_id,
        address: r.address,
        balanceBc400: r.balance_bc400,
        balanceRaw: r.balance_raw,
        txCount: r.tx_count,
        tags: r.tags ? r.tags.split(",").filter(Boolean) : [],
        firstSeen: r.first_seen,
        lastSeen: r.last_seen,
        lastBlockNumber: r.last_block_number ? Number(r.last_block_number) : null,
        lastBlockTime: r.last_block_time,
        lastTxHash: r.last_tx_hash,
      })),
    });
  } catch (err) {
    handleError(res, "top holders", err);
  } finally {
    client.release();
  }
}
app.get("/top-holders", topHoldersHandler);
app.get("/api/top-holders", topHoldersHandler);

// ----------------------
// /transfers – recent transfers (support /api/transfers too)
// ----------------------
async function transfersHandler(req: express.Request, res: express.Response) {
  const client = await pool.connect();
  try {
    const limit = Math.min(Math.max(Number(req.query.limit) || 50, 1), 500);

    const result = await client.query<{
      block_number: string;
      block_time: string | null;
      tx_hash: string;
      from_address: string | null;
      to_address: string | null;
      raw_amount: string;
      log_index: number;
    }>(
      `
      SELECT
        t.block_number,
        t.block_time,
        t.tx_hash,
        af.address AS from_address,
        at.address AS to_address,
        t.raw_amount,
        t.log_index
      FROM transfers t
      LEFT JOIN addresses af ON af.id = t.from_address_id
      LEFT JOIN addresses at ON at.id = t.to_address_id
      ORDER BY t.block_number DESC, t.log_index DESC
      LIMIT $1;
      `,
      [limit]
    );

    res.json({
      transfers: result.rows.map((r) => ({
        block_number: Number(r.block_number),
        block_time: r.block_time,
        tx_hash: r.tx_hash,
        from_address: r.from_address,
        to_address: r.to_address,
        raw_amount: r.raw_amount,
      })),
    });
  } catch (err) {
    handleError(res, "transfers", err);
  } finally {
    client.release();
  }
}
app.get("/transfers", transfersHandler);
app.get("/api/transfers", transfersHandler);

// ----------------------
// /lp/lock – LP burn % + risk label (NO env vars required)
// Auto-detects the PancakeSwap v2 pair for BC400/WBNB
// ----------------------
async function lpLockHandler(_req: express.Request, res: express.Response) {
  try {
    const provider = getProvider();

    const factory = new Contract(PANCAKE_V2_FACTORY, FACTORY_ABI, provider);
    const pairAddress: string = await factory.getPair(BC400_TOKEN, WBNB_TOKEN);

    const isZeroPair =
      !pairAddress || pairAddress.toLowerCase() === ZERO.toLowerCase();

    if (isZeroPair) {
      return res.json({
        ok: true,
        pairFound: false,
        reason: "No PancakeSwap v2 pair found for BC400/WBNB",
        token: { address: BC400_TOKEN },
        wbnb: { address: WBNB_TOKEN },
        updatedAt: new Date().toISOString(),
      });
    }

    const lp = new Contract(pairAddress, ERC20_ABI, provider);

    const [symbol, decimals, totalSupply, deadBal, zeroBal] = await Promise.all([
      lp.symbol().catch(() => "LP"),
      lp.decimals().catch(() => 18),
      lp.totalSupply(),
      lp.balanceOf(DEAD),
      lp.balanceOf(ZERO),
    ]);

    const burned = deadBal + zeroBal;
    const burnedPct =
      totalSupply > 0n ? Number((burned * 1000000n) / totalSupply) / 10000 : 0; // 4dp

    const mode = burnedPct >= 90 ? "burned" : "not-burned";

    let riskLabel: "LOW" | "MEDIUM" | "HIGH" = "MEDIUM";
    if (burnedPct >= 90) riskLabel = "LOW";
    else if (burnedPct < 50) riskLabel = "HIGH";

    res.json({
      ok: true,
      pairFound: true,
      dex: "PancakeSwap v2",
      pairAddress,
      lp: {
        symbol,
        decimals,
      },
      burn: {
        dead: DEAD,
        zero: ZERO,
        totalSupplyRaw: totalSupply.toString(),
        burnedRaw: burned.toString(),
        burnedPct,
        mode,
      },
      lock: {
        detected: false,
        note:
          "No locker detection in this minimal version (no external APIs). We only report burn % on-chain.",
      },
      risk: {
        label: riskLabel,
        note:
          riskLabel === "LOW"
            ? "LP appears strongly burned (good anti-rug signal)."
            : riskLabel === "HIGH"
            ? "LP burn % is low. Liquidity may be withdrawable unless locked elsewhere."
            : "LP burn % is moderate. Could be partially burned or held elsewhere.",
      },
      updatedAt: new Date().toISOString(),
    });
  } catch (err) {
    handleError(res, "lp/lock", err);
  }
}
app.get("/lp/lock", lpLockHandler);
app.get("/api/lp/lock", lpLockHandler);

// ✅ NEW: wire these routes (must exist in src/routes/)
registerDexPriceRoute(app);
registerSecurityRulesRoute(app, pool);

// ----------------------
// /sql – simple SELECT-only console
// ----------------------
app.post("/sql", async (req, res) => {
  const client = await pool.connect();
  try {
    const sql = String(req.body?.sql || "").trim();
    if (!sql.toLowerCase().startsWith("select")) {
      return res.status(400).json({ error: "Only SELECT queries are allowed" });
    }

    const result = await client.query(sql);
    res.json({
      rowCount: result.rowCount,
      rows: result.rows,
      fields: result.fields.map((f) => f.name),
    });
  } catch (err) {
    handleError(res, "sql console", err);
  } finally {
    client.release();
  }
});

// ----------------------
// Start server
// ----------------------
app.listen(PORT, () => {
  console.log(`BC400 API listening on http://localhost:${PORT}`);
});

// Small helper: your original had Math.max; fix typo protection
function Mathmax(a: number, b: number) {
  return Math.max(a, b);
}
